Ackermannfunktion
Die Ackermannfunktion ist eine 1926 von Wilhelm Ackermann gefundene, extrem schnell wachsende mathematische Funktion, mit deren Hilfe in der theoretischen Informatik Grenzen von Computer- und Berechnungsmodellen aufgezeigt werden können. Heute gibt es eine ganze Reihe von Funktionen, die als Ackermannfunktion bezeichnet werden. Diese weisen alle ein ähnliches Bildungsgesetz wie die ursprüngliche Ackermannfunktion auf und haben auch ein ähnliches Wachstumsverhalten. == Entstehungsgeschichte == 1926 vermutete David Hilbert, dass jede berechenbare Funktion primitiv-rekursiv sei. Vereinfacht bedeutet dies, dass sich jede durch einen Computer berechenbare Funktion aus einigen wenigen, sehr einfachen Regeln zusammensetzen lässt und dass sich die Dauer der Berechnung im Voraus abschätzen lässt. Dies trifft auf nahezu alle in der Praxis vorkommenden Funktionen zu. Ebenfalls 1926 konstruierte Ackermann eine Funktion, die diese Vermutung widerlegt, und veröffentlichte sie 1928. Ihm zu Ehren wird diese Funktion heute Ackermannfunktion genannt. Sie kann von einem Computer in endlicher Zeit ausgewertet werden, ist aber nicht primitiv-rekursiv. 1935 konstruierte Rózsa Péter eine vereinfachte Version, die die gleichen Eigenschaften besitzt. Diese Funktion, gelegentlich auch als Ackermann-Péter-Funktion bezeichnet, wird heute vorwiegend benutzt. == Idee == Man betrachtet die Folge :a+b,\ a\cdot b,\ a^b,\ \ldots Hierbei wird bei jedem Folgenglied die Operation des vorigen Folgenglieds (b-1)-mal auf a angewandt, also a\cdot b ist gerade a + a + \dotsb + a, wobei die Variable a b-mal vorkommt und so weiter. Die Idee hinter der Ackermannfunktion ist es, diese Folge als Funktion aufzufassen. Beispiel: : Setzt man in obiger Folge a=2 und b=4, so erhält man die Folge: :: 6,\ 8,\ 16,\ 65536, \underbrace{\ 2^{2^{\;\\!.^{\;\\!.^{\;\\!.^{\;\\!2}}}}}}_{65536\ \mathrm{mal}},\ \ldots :die man auch die Ackermannfunktion zu a=2 und b=4 nennt. Die letztgenannte Zahl liegt bereits weit jenseits von allem Vorstellbaren. Die Ackermannfunktion, notiert als \varphi, ist also eine Funktion, die die folgenden Gleichungen erfüllt: : \varphi(a, b, 0) = a + b\, : \varphi(a, b, 1) = a \cdot b : \varphi(a, b, 2) = a^b\, : \ldots Ab der vierten Zeile können die Funktionswerte nicht mehr mit herkömmlichen Operatoren formuliert werden; man braucht erweiterte Notationen, wie beispielsweise den Hyper-Operator. == Definition und Varianten == Die Ackermannfunktion definiert man üblicherweise rekursiv, d. h. man macht für einige Anfangswerte explizite Angaben und gibt eine Anleitung (das Rekursionsschema), wie man weitere Funktionswerte aus den bereits berechneten erhält. === Definition von Ackermann === Ackermann selbst definierte die Funktion auf recht umständliche Weise, gab aber kurz darauf die folgende äquivalente Definition an: :\varphi(a, b, 0)=a+b\, :\varphi(a, 0, n+1)=\alpha(a, n)\, :\varphi(a, b+1, n+1)=\varphi(a, \varphi(a, b, n+1), n)\, Dabei ist \alpha\left(a, n\right) eine weitere Funktion, die Ackermann nicht weiter beschrieb. Sie liefert die Startwerte a\cdot 0, a^0, \ldots: : \alpha(a, n)=\begin{cases} 0, & \text{wenn } n=0\\\ 1, & \text{wenn } n=1\\\ a, & \text{wenn } n > 1 \end{cases} : Beispiele: :* Möchte man \varphi(4, 3, 0) berechnen, so kann man die erste Zeile der Definition anwenden und erhält direkt: \varphi(4, 3, 0) = 4+3 = 7. :* Möchte man \varphi(4, 0, 2) berechnen, so kann man die zweite Zeile anwenden und erhält: \varphi(4, 0, 2) = \alpha(4, 1) = 1. :* Wenn weder das zweite noch das dritte Argument 0 ist, verwendet man die dritte Zeile der Definition. Beispielsweise \varphi(4, 1, 2)=\varphi(4, \varphi(4, 0, 2), 1). Setzt man \varphi(4, 0, 2)=1 aus dem vorigen Beispiel ein, erhält man \varphi(4, 1, 1). Jetzt kann man wieder die dritte Zeile anwenden, und dann zweimal die zweite. Alles zusammen ergibt: :: \begin{align} \varphi(4, 1, 2) &=\varphi(4, \varphi(4, 0, 2), 1) \\\ &=\varphi(4, 1, 1) \\\ &=\varphi(4, \varphi(4, 0, 1), 0) \\\ &=\varphi(4, 0, 0) \\\ &=4 \end{align} Wenn man vom Wachstum der Ackermannfunktion spricht, meint man oftmals die Funktion f\left(n\right) := \varphi(n, n, n). === Definition von Péter === Rózsa Péter definierte 1935 eine einfachere Version der Ackermannfunktion, die nur zwei Parameter besitzt und zudem ohne die Hilfsfunktion \alpha auskommt:Péter Rózsa: Konstruktion nichtrekursiver Funktionen. In: Mathematische Annalen, 111, 1935, S. 42–60 : \begin{array}{lcl} \operatorname{a}(0, m) & = & m+1 \\\ \operatorname{a}(n+1, 0) & = & \operatorname{a}(n, 1) \\\ \operatorname{a}(n+1, m+1) & = & \operatorname{a}(n, \operatorname{a}(n+1, m)) \end{array} Auch hier meint man im Zusammenhang mit Wachstumsuntersuchungen oftmals die Funktion f(n) := \operatorname{a}(n, n), wenn man von der Ackermannfunktion spricht. Aus dieser Definition ist nicht sofort ersichtlich, dass die Funktion \operatorname{a}(n, m) für alle nicht negativen, ganzzahligen n und m definiert ist, da m teilweise auch erhöht wird. Man kann aber erkennen, dass zum einen \operatorname{a}(n, \cdot) für n=0 wohldefiniert ist. Zum anderen ist unter der Voraussetzung, dass \operatorname{a}(n_0, \cdot) wohldefiniert ist, auch \operatorname{a}(n_0+1, \cdot) wohldefiniert, indem man die letzten beiden Rekursionsvorschriften iterativ benutzt. Zu beachten ist allerdings, dass es bei einer Verringerung von n keine obere Schranke für das Wachstum von m in den folgenden Funktionsaufrufen gibt. === Modifizierte Ackermannfunktion === Häufig werden in der Komplexitätsanalyse leicht modifizierte Versionen der Ackermannfunktion verwendet, die jedoch das gleiche asymptotische Laufzeitverhalten aufweisen. Eine dieser Varianten, die eine Interpretation als „verallgemeinerte Exponentialfunktion“ erlaubt, kann wie folgt angegeben werden:P. K. Agarwal, M. Sharir: Davenport-Schinzel sequences and their geometric applications. In: Handbook of computational geometry, 2000, S. 1–47. : \begin{array}{lcl} A_1(n) & = & 2n & \text{wenn }n\geq1, \\\ A_k(1) & = & 2 & \text{wenn }k\geq2, \\\ A_k(n) & = & A_{k-1}(A_k(n-1)) & \text{wenn }n\geq2, k\geq2. \end{array} Die so definierte Folge von Funktionen A_k können nun zu der Definition der modifizierten Ackermannfunktion A verwendet werden, indem man : A(n) = A_n(n)\, setzt. Die Funktionen A_k können nun als natürliche Fortsetzung der Addition, Multiplikation und Potenzierung interpretiert werden. So repräsentiert beispielsweise A_1(n) die n-fache Addition der Zahl 2, A_2(n) die n-fache Multiplikation der Zahl 2 usw. Es gilt : A_1(k) = 2+2+2+\dotsb+2 = 2\cdot k : A_2(k) = 2\cdot 2\cdot 2\dotsm 2 = 2^k : A_3(k) = 2^{2^{2^{{}^{.\,^{.\,^{.\,^2}}}}}} == Bedeutung in der theoretischen Informatik == Wie eingangs schon erwähnt, erfand Ackermann diese Funktion als Beispiel einer Funktion, die nicht primitiv-rekursiv, aber berechenbar ist. Auf der Suche nach den Grenzen von Computern stößt man sehr schnell auf den Begriff der berechenbaren Funktionen. Das sind all die Funktionen, für deren Auswertung man einen Algorithmus angeben kann, also alle Funktionen, die ein Computer (insbesondere eine Turingmaschine) berechnen kann. Diese Definition stellt einen sehr schnell vor ein Problem, wenn man von einer konkreten Funktion entscheiden möchte, ob sie berechenbar ist. Findet man einen Algorithmus, der die Funktion berechnet, so ist sie offensichtlich berechenbar. Andernfalls ist ungewiss, ob die Funktion wirklich nicht berechenbar ist oder ob es zwar einen Algorithmus gibt, man ihn aber nicht gefunden hat. Aus diesem Grund sucht man nach alternativen Definitionen, mit denen man einen solchen Nachweis einfacher führen kann. Ein erster Ansatz hierfür waren die primitiv-rekursiven Funktionen. Dies sind Funktionen, die sich durch einige wenige Regeln aus sehr einfachen Funktionen zusammensetzen lassen. Einige Zeit vermutete man, dass alle berechenbaren Funktionen primitiv-rekursiv sind, mit den primitiv-rekursiven Funktionen also ein Werkzeug zur Lösung des oben geschilderten Problems gefunden sei. Diese Hoffnung zerstörte jedoch die Ackermannfunktion, von der man nachweisen kann, dass sie berechenbar, aber nicht primitiv-rekursiv ist. (Siehe nachfolgender Beweis.) Führt man auf der Klasse der primitiv-rekursiven Funktionen eine weitere Konstruktionsregel, die sogenannte µ-Rekursion, ein, erhält man eine größere Klasse ebenfalls berechenbarer Funktionen, die die Ackermannfunktion enthält. Man nimmt an, dass diese Klasse der µ-rekursiven Funktionen der Klasse der intuitiv berechenbaren Funktionen entspricht (Church'sche These). === Beweis === Der Beweis, dass die Ackermannfunktion berechenbar ist, aber nicht primitiv-rekursiv, nutzt im Wesentlichen aus, dass die Ackermannfunktion stärker wächst als jede primitiv-rekursive Funktion.Für Details zum Beweis sehe man z. B. im Buch von Uwe Schöning nach (siehe Literatur). Beweisskizze zur Behauptung, dass die Ackermannfunktion nicht primitiv-rekursiv ist: * Als erstes definiert man zu jeder primitiv-rekursiven Funktion g, eine Funktion *: f_g(n):=\max\left\\{g(n_1, \ldots, n_k):\sum_{i=1}^{k}n_i\leq n\right\\} *: Diese Funktion gibt das Maximum an, das man mit g erreichen kann, wenn die Summe der Argumente n nicht überschreitet. * Sodann zeigt man durch strukturelle Induktion über den induktiven Aufbau der primitiv-rekursiven Funktionen, dass es zu jeder primitiv-rekursiven Funktion g eine natürliche Zahl k gibt, sodass für alle n \geq k gilt: f_g(n) < a(k, n). Anschaulich zeigt dies, dass die Ackermannfunktion stärker wächst als jede primitiv- rekursive Funktion. * Damit beweist man dann, wie folgt, dass die Ackermannfunktion nicht primitiv-rekursiv ist: *: Angenommen, a(k,n) sei primitiv-rekursiv, dann auch g(n) := a (n, n). Nach der Vorbemerkung gibt es aber ein k, sodass für alle n \geq k gilt: g(n) < a(k, n). Setzt man hier n = k so erhält man den Widerspruch: *:: g(k)\leq f_g(k) < a(k, k) = g(k) == Anwendungen == Für die Ackermannfunktion gibt es nur sehr wenige Anwendungen. Die zwei wichtigsten sind Benchmarktests für rekursive Aufrufe in Programmiersprachen und Laufzeitabschätzungen der gewichteten Vereinigung und Pfadkompression bei der Union-Find-Struktur. === Benchmark für rekursive Aufrufe === Bei der Einführung von neuen Programmiersprachen, Compilern und Computern möchte man deren Leistungsfähigkeit untersuchen. Dazu werden u. a. mittels Benchmarking durch spezielle Programme festgelegte Eigenschaften überprüft. In diesem Zusammenhang wird die Ackermannfunktion gerne als Benchmark zur Überprüfung von rekursiven Prozedur-Aufrufen benutzt, da ein Programm zur Berechnung der Ackermannfunktion im Wesentlichen nur aus solchen Prozeduraufrufen besteht. In der Definition von Péter wird ja nur a(0, m) direkt berechnet. Die Schwierigkeit bei der Berechnung der Funktionswerte sind also nicht allein deren Größe, sondern die tiefe Verschachtelung der Funktionsaufrufe, die leicht zu einem Stapelüberlauf (engl. Stack Overflow) führt, also dazu, dass dem System der Speicher ausgeht. Die Ackermann-Funktion ist daher eine einfache und sichere Methode, einen Stapelüberlauf zu provozieren, beispielsweise um zu testen, ob dieser Fehlerfall bearbeitet wird und ggf. wie dies erfolgt. Die Ackermann-Funktion hat dabei den Vorteil, dass sie immun gegen Compiler-Optimierungen ist und auch statische Quellcode- Analysen den (möglichen) Stapelüberlauf praktisch nicht detektieren können. Diese Idee geht zurück auf Yngve Sundblad, der 1971 die Funktion f(n):=a(3, n) benutzte, um diverse Programmiersprachen zu vergleichen. Um a(3, n) zu berechnen, werden a(3, n)+12^n-2 Aufrufe getätigt. Sundblad testete unter anderem, wie groß n gewählt werden kann, damit der Computer noch in der Lage ist, diese Zahl zu berechnen. Damals erreichte er n=1. Zum Vergleich hierzu: Mit Java 1.4.2 und den Standardspeichereinstellungen erreicht man heutzutage n=13. Im Laufe der Berechnung werden viele identische Aufrufe mehrfach ausgerechnet. Ein intelligenter Compiler kann dies ausnutzen und die Ergebnisse zwischenspeichern, um solche Aufrufe nur einmal durchführen zu müssen. Damit waren schon 1971 Aufrufe bis n=20 durchführbar. Einen bedeutenden Zeitvorteil erhält man auch, wenn man a(1, n) direkt berechnet, statt es rekursiv zu a(1, a(1, a(1, \dots, a(1, 0)\dots))) zu expandieren. Die direkte Berechnung von a(1, n) erfordert lineare Zeit in n. Die Berechnung von a(2, n) erfordert quadratische Zeit, denn sie führt zu \mathcal{O}(n) (also c\cdot n für eine Konstante c; siehe Landau-Symbole) verschachtelten Aufrufen von a(1, i) für verschiedene i. Die Berechnung von a(3, n) erfordert schließlich eine zu 4^{n+1} proportionale Zeit (\mathcal{O}(4^{n+1})). === Laufzeitabschätzungen mit der Umkehrfunktion === Da die Funktion f(n): = a(n, n) sehr schnell wächst, wächst ihre Umkehrfunktion f^{-1} sehr langsam. Sie ist für jede praktisch vorstellbare Eingabegröße kleiner als 5, weil der Funktionswert f(4)=a(4, 4) größer als die Anzahl der Atome im Universum ist, wie die Berechnung von a(4, 3) weiter unten zeigt. In der praktischen Analyse von Algorithmen kann sie also als konstant betrachtet werden. Diese Umkehrfunktion taucht in der Laufzeitanalyse bestimmter Algorithmen auf, zum Beispiel beim Union-Find-Problem und in Chazelles Algorithmus für minimale Spannbäume. In diesem und anderen Zusammenhängen wird die ursprüngliche Ackermannfunktion oft durch Weglassen additiver Konstanten oder andere Modifikationen leicht umdefiniert zu einer Funktion mit ähnlichem asymptotischen Verhalten. Diese modifizierten Funktionen sind nicht gleich der Ackermannfunktion, aber nach den Maßstäben der Laufzeitanalyse können sie als äquivalent betrachtet werden. == Implementierung == Die rekursive Implementierung der Ackermannfunktion (hier in Pseudocode) entspricht direkt der Definition: function ack(n, m) if n = 0 return m + 1 else if m = 0 return ack(n - 1, 1) else return ack(n - 1, ack(n, m - 1)) Etwas effizienter ist die folgende, teilweise iterative Implementierung: function ack(n, m) while n ≠ 0 if m = 0 m:= 1 else m:= ack(n, m - 1) n:= n - 1 return m + 1 Noch effizientere Implementierungen verwenden Arrays zur Zwischenspeicherung bereits berechneter Werte, siehe auch Dynamische Programmierung. Grossman & Zeitman publizierten einen Algorithmus der \operatorname{a}(n,m) ohne Zwischenspeicherung berechnet in Laufzeit \mathcal{O}(n \operatorname{a}(n,m)), mit einem Speicherbedarf von \mathcal{O}(n). In Haskell, einer funktionalen Programmiersprache, spiegelt die Implementierung direkt die Definition wider: ack 0 m = m+1 ack n 0 = ack (n-1) 1 ack n m = ack (n-1) (ack n (m-1)) In Prolog sieht die Implementierung so aus: ackermann(0,X,Y) :- X >= 0,!, Y is X + 1. ackermann(X,0,Z) :- X > 0,!, X1 is X - 1, ackermann(X1,1,Z). ackermann(X,Y,Z) :- X > 0, Y > 0, X1 is X-1, Y1 is Y - 1, ackermann(X,Y1,W), ackermann(X1,W,Z). Im Lambda-Kalkül ist sogar eine rein iterative Implementierung möglich. 1 und succ verwenden die Church- Numerale zur Darstellung der natürlichen Zahlen. Die Gleichungen der Definition von Péter lassen sich direkt durch β-Konversion zeigen. ack ≡ λn. n (λf.λm. m f (f 1)) succ == Wertetabelle == Die folgende Tabelle zeigt einige Funktionswerte für kleine Werte von n und m. Die nicht vollständig ausgerechneten Werte sind zu groß, um sie dezimal darzustellen. {| class="wikitable" |+ Werte von a(n, m) |- class="hintergrundfarbe6" ! n \ m ! 0 ! 1 ! 2 ! 3 ! 4 ! ... ! m |- ! class="hintergrundfarbe8"| 0 | 1 | 2 | 3 | 4 | 5 | ... | m+1 |- ! class="hintergrundfarbe8"| 1 | 2 | 3 | 4 | 5 | 6 | ... | m+2 |- ! class="hintergrundfarbe8"| 2 | 3 | 5 | 7 | 9 | 11 | ... | 2m+3 |- ! class="hintergrundfarbe8"| 3 | 5 | 13 | 29 | 61 | 125 | ... | 8\cdot 2^m-3 |- ! class="hintergrundfarbe8"| 4 | 13 | 65533 | 2^{65536}-3 \approx 2 \cdot 10^{19728} (Zahl mit 19729 Dezimalstellen) | a(3, 2^{65536} - 3) | a(3, a(4, 3)) | ... | \begin{matrix}\underbrace{{2^2}^{{\cdot}^{{\cdot}^{{\cdot}^2}}}} - 3 \end{matrix} (Potenzturm mit m+3 Zahlen) |- ! class="hintergrundfarbe8"| 5 | 65533 | a(4, 65533) | a(4, a(5, 1)) | a(4, a(5, 2)) | a(4, a(5, 3)) | | |- ! class="hintergrundfarbe8"| 6 | a(5, 1) || a(5, a(5, 1)) | a(5, a(6, 1)) | a(5, a(6, 2)) | a(5, a(6, 3)) | | |} Trotz der unvorstellbar großen Zahlen, die schon in dieser Tabelle auftauchen, wurden rekursive Verfahren definiert, die noch schneller wachsende Werte liefern, so zum Beispiel Grahams Zahl. {| class="wikitable" |+ Benötigter Speicher für a(n, m), wenn als unsigned integer gespeichert. |- class="hintergrundfarbe6" ! m \ n ! 0 ! 1 ! 2 ! 3 ! 4 ! 5 |- ! class="hintergrundfarbe8"| 0 | 1 bit || 2 bit || 2 bit || 3 bit || 4 bit |16 bit |- ! class="hintergrundfarbe8"| 1 | 2 bit || 2 bit || 3 bit || 4 bit || 16 bit (24 bit) | |- ! class="hintergrundfarbe8"| 2 | 2 bit || 3 bit || 3 bit || 5 bit || 8 KiB (216 bit) | |- ! class="hintergrundfarbe8"| 3 | 3 bit || 3 bit || 4 bit || 6 bit || ≈2,504412...·1019727 Byte (265536 bit = 265533 Byte) | |- ! class="hintergrundfarbe8"| 4 | 3 bit || 3 bit || 4 bit || 7 bit || | |- ! class="hintergrundfarbe8"| 5 | 3 bit || 3 bit || 4 bit || 8 bit || | |- ! class="hintergrundfarbe8"| 6 | 3 bit || 4 bit || 4 bit || 9 bit || | |- ! class="hintergrundfarbe8"| 7 |4 bit |4 bit |5 bit |10 bit | | |- ! class="hintergrundfarbe8"| 8 |4 bit |4 bit |5 bit |11 bit | | |- ! class="hintergrundfarbe8"| 9 |4 bit |4 bit |5 bit |12 bit | | |- ! class="hintergrundfarbe8"| 10 |4 bit |4 bit |5 bit |13 bit | | |- ! class="hintergrundfarbe8"| 100 |7 bit |7 bit |8 bit |103 bit | | |- ! class="hintergrundfarbe8"| 1'000 |10 bit |10 bit |11 bit |125⅜ Byte | | |- ! class="hintergrundfarbe8"| 10'000 |14 bit |14 bit |15 bit |1250⅜ Byte | | |- ! class="hintergrundfarbe8"| 100'000 |17 bit |17 bit |18 bit |≈12,5 KB (105 bit) | | |- ! class="hintergrundfarbe8"| 1'000'000 |20 bit |20 bit |21 bit |≈125 KB (106 bit) | | |- ! class="hintergrundfarbe8"| 10'000'000 |24 bit |24 bit |25 bit |≈1,25 MB (107 bit) | | |- ! class="hintergrundfarbe8"| 100'000'000 |27 bit |27 bit |28 bit |≈12,5 MB (108 bit) | | |- ! class="hintergrundfarbe8"| 232−1 |33 bit |33 bit |34 bit |≈512 MiB (232 bit) | | |- ! class="hintergrundfarbe8"| 264−1 |65 bit |65 bit |66 bit |≈2 EiB (264 bit) | | |} == Genauere Betrachtung == Anhand der Wertetabelle lässt sich ein Schema zur Berechnung der Funktionswerte herleiten, das leichter zu verstehen ist als die formale rekursive Definition. Es ist leicht zu erkennen, dass die Werte der ersten Zeile einfach eine Liste aller natürlichen Zahlen sind. Die jeweiligen Einträge können mit der Formel a(0, m) = m + 1 berechnet werden. Alle folgenden Zeilen enthalten einfach Anweisungen, in dieser Zeile einen Wert zu suchen. Im Falle der Zeile n=1 vereinfacht sich diese Anweisung dazu, den Wert a(0, m+1) in der Zeile n=0 zu suchen, aber diese Vereinfachung ist schon etwas schwieriger herzuleiten – zum Beispiel: a(1, 2) = a(0, a(1,1)) = a(0, a(0, a(1,0))) = a(0, a(0, 2)) = a(0, 3) = 4 Wir betrachten nun einen komplexeren Fall, nämlich a(4, 3), den ersten Funktionswert, der so groß ist, dass er praktisch nicht dezimal aufgeschrieben werden kann. a(4, 3) = a(3, a(4, 2)) = a(3, a(3, a(4, 1))) = a(3, a(3, a(3, a(4, 0)))) = a(3, a(3, a(3, a(3, 1)))) = a(3, a(3, a(3, a(2, a(3, 0))))) = a(3, a(3, a(3, a(2, a(2, 1))))) = a(3, a(3, a(3, a(2, a(1, a(2, 0)))))) = a(3, a(3, a(3, a(2, a(1, a(1, 1)))))) = a(3, a(3, a(3, a(2, a(1, a(0, a(1, 0))))))) = a(3, a(3, a(3, a(2, a(1, a(0, a(0, 1))))))) = a(3, a(3, a(3, a(2, a(1, a(0, 2)))))) = a(3, a(3, a(3, a(2, a(1, 3))))) = a(3, a(3, a(3, a(2, a(0, a(1, 2)))))) = a(3, a(3, a(3, a(2, a(0, a(0, a(1, 1))))))) = a(3, a(3, a(3, a(2, a(0, a(0, a(0, a(1, 0)))))))) = a(3, a(3, a(3, a(2, a(0, a(0, a(0, a(0, 1)))))))) = a(3, a(3, a(3, a(2, a(0, a(0, a(0, 2)))))) = a(3, a(3, a(3, a(2, a(0, a(0, 3))))) = a(3, a(3, a(3, a(2, a(0, 4))))) = a(3, a(3, a(3, a(2, 5)))) = ... Das ist für einige Zeit der einfachste Fall einer solchen Expansion, und es ist anhand der Tabelle offensichtlich, warum Funktionswerte wie dieser selten direkt berechnet werden. Es ist auch interessant festzustellen, wie viele Schritte nötig sind, um schon sehr einfach aussehende Ackermann-Ausdrücke zu vereinfachen. Jede Zeile im vorigen Beispiel ist eine einzige Anwendung eines der drei Teile der Definition der Ackermannfunktion. … = a(3, a(3, a(3, 13))) = ... = a(3, a(3, 65533)) Wenn wir an dieser Stelle mehrere logische Schritte überspringen, könnten wir a(2, 5) zu 13 auswerten und dann versuchen, a(3, 13) auszuwerten – das ist 65533. Doch schon der nächste Funktionsaufruf liefert mit a(3, 65533) eine Zahl, die weit über die geschätzte Anzahl der Atome im Universum hinausgeht. Diese Zahl m wird schließlich in die Berechnung a(3, m) eingesetzt, die irgendwann zu einem Ausdruck der Form a(2, a(2, a(2, \dots, a(2, 0)\dots))) ausgeschrieben würde, die aber mit unseren Mitteln nicht mehr aufgeschrieben werden kann. Ein weiterer interessanter Aspekt der Ackermann- Funktion ist, dass die einzige Berechnung, die neben den rekursiven Aufrufen tatsächlich auftaucht, die Berechnung von a(0, m) ist, die einfach m um 1 erhöht. == Literatur == * * * Dexter C. Kozen: The Design and Analysis of Algorithms. Springer, Berlin 1992, ISBN 3-540-97687-6. * Uwe Schöning: Theoretische Informatik – kurzgefasst. Spektrum Akademischer Verlag, Heidelberg 2001, ISBN 3-8274-1099-1. * Yngve Sundblad: The Ackermann Function. A Theoretical, Computational, and Formula Manipulative Study. In: BIT – numerical mathematics. Springer, Dordrecht 11.1971, S. 107–119, . == Weblinks == * Erklärungsvideo zur Ackermannfunktion (englisch) == Einzelnachweise == Kategorie:Berechenbarkeitstheorie Kategorie:Mathematische Funktion 