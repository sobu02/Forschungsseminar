Komplexitätstheorie Komplexitätstheorie Teilgebiet theoretischen Informatik Komplexität algorithmisch behandelbarer Probleme verschiedenen formalen Rechnermodellen Komplexität Algorithmen Ressourcenverbrauch Rechenzeit Speicherplatzbedarf speziellere Maße Größe Schaltkreises Anzahl benötigter Prozessoren parallelen Algorithmen Komplexität Problems Komplexität desjenigen Algorithmus Problem geringstmöglichen Ressourcenverbrauch Komplexitätstheorie Berechenbarkeitstheorie Frage Probleme prinzipiell algorithmisch wichtigste Forschungsziel Komplexitätstheorie Menge lösbaren Probleme Menge effizient lösbaren Probleme Ressourcenverbrauch Praxis Menge inhärent schwierigen Probleme Einordnung Theoretische Informatik Komplexitätstheorie theoretischen Informatik Komplexitätstheorie Berechenbarkeitstheorie Theorie Formalen Sprachen Hauptbereiche Theoretischen Informatik wesentlichen Forschungszielen Klassifizierung Problemen Hinblick Lösung notwendigen Aufwand besondere Rolle Abgrenzung praktisch effizient lösbaren Probleme Komplexitätstheorie Probleme andere Disziplinen Informatik effizienten Lösungen Entwicklung praxistauglicher Approximationsalgorithmen reinen Erkenntnisgewinn Methodenarsenal komplexitätstheoretischen Forschung zahlreiche angrenzende Gebiete enge Verzahnung Automatentheorie neuen Maschinenmodellen umfassenderen Verständnis Arbeitsweise Automaten häufig konstruktive Beweisführung Rahmen Entwurfs Analyse Algorithmen Datenstrukturen Anwendung Probleme Sicht Komplexitätstheorie Entscheidungsprobleme formale Sprachen mini|Entscheidungsproblem zentralen Gegenstand Komplexitätstheorie Probleme Regel Entscheidungsprobleme Instanzen Ja/Nein-Antwort Entscheidungsproblem formale Sprache Probleminstanz Wort Alphabet Folge Zeichen Alphabet fragliche Sprache Wörtern Instanz Antwort Ja Aufgabe Lösung Wortproblems gegebenes Wort Sprache Antwort entsprechende Probleminstanz Beispiel Problem Graph zusammenhängend Wort Darstellung beliebigen Graphen zugehörige entscheidende Sprache Menge Wörter zusammenhängenden Graphen Einschränkung Entscheidungsprobleme wichtige Probleme Sinne Komplexitätstheorie relevanten Problemen entsprechendes Entscheidungsproblem Betrachtet Beispiel Problem Multiplikation zweier Zahlen dazugehörige Sprache Entscheidungsproblems Zahlen-Tripeln Zusammenhang \cdot Entscheidung gegebenes Tripel Sprache Problems Multiplikation zweier Zahlen Berechnungsprobleme Abbildungen Entscheidungsproblemen Berechnungsprobleme Antwort Problemlösung Multiplikationsproblem Praxis Berechnungsproblem Produkt zweier Zahlen Berechnungsproblem Abbildung Definitionsbereich Lösungsraum Fall Multiplikation natürlichen Zahlen Abbildung b anderes Beispiel Problem Handlungsreisenden optimalen Reihenfolge gegebene Orte Gesamtlänge Route minimal Optimierungsprobleme großer praktischer Bedeutung Definition Komplexitätsklassen Formulierung Entscheidungsprobleme wichtige Unterkategorie Berechnungsprobleme Optimierungsprobleme Optimierungsproblemen funktionale Zusammenhang Forderung Maximum Minimum gegebenen Kostenfunktion möglichen Lösungen Problems Problem Handlungsreisenden Länge optimalen Route Probleminstanzen Probleminstanz Problem Problem Komplexitätstheorie allgemeine Fragestellung Schablone Instanz Problems vollständige Fragestellung richtige Antwort Fall Entscheidungsproblems Instanz Problems Handlungsreisenden Beispiel Frage Route Landeshauptstädte Deutschlands maximalen Länge km Entscheidung Route begrenzten Wert andere Probleminstanzen Rundreise Sehenswürdigkeiten Mailands Komplexitätstheorie Aussagen unabhängig konkreten Instanzen Problem allgemein unendliche Menge Probleminstanzen sinnvoll Komplexität endlichen Menge Instanzen Programm Liste vorgefertigten Antworten Tabellenzugriff richtige Lösung Aufwand Ermittlung Antworten Interessant unendliche Menge Instanzen Algorithmus Instanz richtige Antwort Problemrepräsentationen formale Sprachen Probleme Instanzen abstrakten Alphabeten Häufig binäre Alphabet Symbolen Verwendung Bits modernen Rechnern nächsten Eingaben Alphabetsymbole Stelle mathematischen Objekten Graphen Bitfolge Adjazenzmatrix Graphen Stelle natürlichen Zahlen Beispiel Binärdarstellung Beweise komplexitätstheoretischer Aussagen Regel konkreter Repräsentationen Eingabe Aussagen Betrachtung unabhängig Repräsentationen gewählte Repräsentation Bedarf großen Aufwand andere Repräsentation Berechnungsaufwände signifikant Auswahl geeigneten universellen Maschinenmodells Bedeutung Problemgröße Problem formal Beispiel Problem Handlungsreisenden Form Graphen Kantengewichten Aussagen Algorithmus Berechnung Problemlösung Abhängigkeit Schwierigkeit Problems Allgemeinen Beurteilung Schwierigkeit Problems verschiedene Aspekte häufig skalare Größen Verhalten Algorithmus Hinblick Ressourcenverbrauch maßgeblich Größen Problemgröße Regel Eingabelänge konkret gewählten Repräsentation Eingabe Verhalten Algorithmus Abhängigkeit Problemgröße Komplexitätstheorie Frage Mehrarbeit wachsende Problemgrößen notwendig Aufwand Relation Problemgröße Beispiel linear polynomial exponentiell überexponentiell Problem Handlungsreisenden Problemgröße Anzahl vorgegebenen Orte vorgegebenen Streckenlängen große Eingabegrößen Problem Problemgröße trivial mögliche Lösung optimal zunehmender Problemgröße Algorithmus Arbeit Bester schlechtester durchschnittlicher Fall Problemgrößen Problemgröße verschiedene Verhaltensweisen Algorithmen Problem Handlungsreisenden deutschen Landeshauptstädte Problemgröße Route europäische Hauptstädte Algorithmus unterschiedlichen Bedingungen gleicher Problemgröße gut Regel unendlich Instanzen gleicher Größe Problem grob Gruppen bester durchschnittlicher schlechtester Fall Fragen Bester Fall Algorithmus Bezug Frage stehende Ressource günstigsten Fall Durchschnittlicher Fall Algorithmus durchschnittlich zugrundegelegte Verteilung Berechnung Durchschnitts offensichtlich Amortisierter Fall Algorithmus schlechtesten Fall Folge Schlechtester Fall Algorithmus schlimmsten Fall Funktionen Ergebnissen Fragen scharf aufsteigend Problem quadratischen Bedarf quadratischen Bedarf Durchschnitt schlechtesten Fall geringeren Untere obere Schranken Probleme Betrachtung bester schlechtester durchschnittlicher Fälle feste Eingabelänge Betrachtung konkreter Eingabelängen Praxis großem Interesse Sichtweise Komplexitätstheorie abstrakt Eingabelänge groß praktisch relevant technischer Entwicklungen schnell Verhalten Algorithmen Bezug Problem gänzlich unabhängig konkreten Eingabelängen Verhalten Algorithmen größer werdende potentiell unendlich große Eingabelängen asymptotischen Verhalten jeweiligen Algorithmus Untersuchung asymptotischen Ressourcenverbrauchs untere obere Schranken zentrale Rolle Ressourcen Entscheidung Problems Komplexitätstheorie unteren Schranken besonderem Interesse bestimmtes Problem bestimmten Ressourcenverbrauch Algorithmus Problem geringeren Ressourcen Ergebnisse Probleme nachhaltig Schwierigkeit aussagekräftige untere Schranken Grund Problematik Untersuchungen unterer Schranken denkbaren Algorithmen Problem Algorithmen bekannt Gegensatz Nachweis oberer Schranken Regel Analyse konkreter Algorithmen Beweis Existenz Algorithmus obere Schranke Nachweis bestimmten Problemen Komplexität Verschlüsselungsverfahren Nachweis erwartende Ressourcenverbrauch Versuch Verfahren realistische Maß Probleme Computer Größe Erde Lebensdauer Erde Begriff transcomputationales Problem Maschinenmodelle Komplexitätstheorie Kostenfunktionen Analyse Ressourcenverbrauchs Algorithmen geeignete Kostenfunktionen Zuordnung Arbeitsschritte Algorithmus verbrauchten Ressourcen Art Arbeitsschritt Algorithmus Festlegung Komplexitätstheorie abstrakte Maschinenmodelle reale Rechnermodelle gewonnenen Erkenntnisse Jahren Arbeitsschritt Algorithmus Form Befehlsausführung bestimmten Maschine Befehle Maschine jeweilige Modell streng verschiedene Modelle Handhabung Speichers Fähigkeiten parallelen Verarbeitung gleichzeitigen Ausführung Befehle Definition Kostenfunktion Zuordnung Kostenwerten erlaubten Befehlen Kostenmaße Häufig unterschiedlichen Kosten unterschiedliche Befehle Kostenwert Befehlsausführung Maschine Addition Multiplikation erlaubten Operationen Addition Multiplikation Laufe Algorithmus Kostenwert uniformen Kostenmaß Vorgehen erlaubten Operationen gravierend Wertebereich Operationen eingeschränkt groß einfache Operation Multiplikation klar Produkt zweier einstelliger Dezimalzahlen ungleich schneller Produkt zweier hundertstelliger Dezimalzahlen uniformen Kostenmaß Operationen Kostenwert möglichen Operanden Laufe Algorithmus tatsächlich gravierend realistischeres Kostenmaß Häufig logarithmische Kostenmaß Bezug Logarithmus Dezimalzahl Wesentlichen Binärziffern Repräsentation Operanden Binärziffern erlaubten booleschen Operationen jeweilige Maschinenmodell Adressen binär Weise Kosten Länge Binärdarstellung logarithmisch Andere Kostenmaße möglich selten Maschinenmodelle Probleme verschiedene Berechnungsparadigmen pragmatischste Typ sicher deterministischen Maschinen Theorie relevanten Typ nichtdeterministischen Maschinen probabilistische Maschinen alternierende andere Regel Maschinenmodell obigen Paradigmen Paradigmen Beispiel Nichtdeterminismus Typ Theorie vorbehalten Nichtdeterminismus definierten Form physikalisch richtigen Pfad Berechnungsbaum häufig leicht gegebenen Problem Transformation nichtdeterministischen deterministische Maschinen relativ möglich nichtdeterministische Maschinenversion später deterministische wichtige Beweistechnik Komplexitätstheorie gegebenen Problem bestimmter Maschinentyp Problem bestimmten Kosten Komplexität Problems Tatsächlich unterschiedlichen Maschinenmodelle Definition Komplexitätsklassen Abstraktion konkreten Algorithmus Problem Maschine M entscheidbar entsprechender Algorithmus bekannt unmittelbar bestimmten Komplexitätsklasse M Verhältnis Problemen Maschinenmodellen Beweisführungen umständliche Analyse Algorithmen Häufig eingesetzte Maschinenmodelle häufig eingesetzte Modelle Turingmaschine.svg|Turingmaschine Registermaschine.svg|Registermaschine Kellerautomat.svg|Kellerautomat Nichtdeterministischer endlicher Automat 2.svg|Endlicher Automat Untersuchung parallelisierbarer Probleme parallelisierte Versionen Maschinen Einsatz parallele Registermaschine erweiterte Church-Turing-These Verwendung Maschinenmodellen Komplexitätstheorie Erweiterung Church-Turing-These Bedeutung erweiterte Church-Turing-These universellen Maschinenmodelle Bezug Rechenzeit polynomielle Faktoren mächtig Komplexitätstheoretiker relativ freie Wahl Maschinenmodells Hinblick jeweilige Untersuchungsziel These beweisbar Gegensatz gewöhnlichen Church-Turing-These möglich Gegenbeispiel Modellmodifikationen Speicherplatzanalysen Untersuchung Mindestspeicherbedarfs Lösung Problemen häufig folgenden Modifikationen verwendeten Maschinenmodells Regel Turingmaschine Eingabespeicher Ausgabe Schreibkopf Schreibvorgängen Richtung Maschinenmodell Bewegung Untersuchung Speicherbedarfs Ausgabe Maschine Motivation Änderungen folgende Würde Beispiel Eingabespeicher Speicherplatzanalyse Problem Platzbedarf Eingabewort genau Länge Speicherbedarf Eingabe lesbar Zwischenrechnungen Eingabe Berechnung Platzbedarfs ähnliche Argumentation Einschränkung Ausgabe zusätzliche Einschränkung möglichen Kopfbewegung Kopfposition Information Einschränkungen sicher Ausgabe Speicherplatzanalyse vorgenommenen Modifikationen Zeitverhalten Maschine konstanten Faktor vernachlässigbar Untersuchung Größenordnungen Aufwände Komplexitätstheorie ausgiebig O-Notation Gebrauch minimalen mittleren maximalen Speicherplatzbedarf Algorithmus Zeitkomplexität Platzkomplexität Komplexität verwendeten Maschinenmodell Regel normales Modell Beispiel Turingmaschine äquivalentes lineare Faktoren Konstanten Betrachtung Vorgehensweise Praktiker häufig Halbierung Aufwände hoher Bedeutung Standpunkt Komplexitätstheorie theoretisch Technik lineares Speedup-Theorem Zeitverhalten Analoge Beweise Speicherbedarf andere Ressourcen Speedup-Theorem vereinfachend Turingmaschine Problem Zeit T neue Turingmaschine Problem Zeit \varepsilon \cdot T \varepsilon beliebig klein Turingmaschine bestimmtes Problem beliebigen konstanten Faktor Preis Beschleunigung stark vergrößerten Arbeitsalphabetgröße Zustandsmenge verwendeten Turingmaschine Hardware Beschleunigung unabhängig Problemgröße Betrachtung asymptotischen Verhaltens Problemen Sinn konstante Faktoren Faktoren Anwendung Beschleunigungstechnik Vernachlässigung konstanter Faktoren O-Notation praktische Gründe Verfälschungen Rahmen komplexitätstheoretischer Betrachtungen aufwendig unmöglich Problem L Funktion f_L\colon w \rightarrow allgemein beliebigen Eingabe Problem zugehörige Anzahl Rechenschritte Speicherzellen Regel Eingabe einzeln Eingabelänge aufwendig Funktion f_L\colon \rightarrow Landau-Notation asymptotische Verhalten Funktion Schranken Rechenaufwand Bedarf Speicher Rechenzeit Eingabe wichtigste Symbol großer lateinischer Buchstabe obere Schranken untere Schranken Allgemeinen schwieriger g g Konstante \in g anderen Worten Eingabelängen Rechenaufwand wesentlich größer konstanten Faktor g Funktion bekannt Funktion g Funktion Wachstum bekannt g g =2^x Landau-Notation Rechenaufwand Platzbedarf aufwendig genaue Funktion Landau-Symbole Probleme Algorithmen Komplexität Komplexitätsklassen Komplexitätstheorie verschiedenen Probleme Algorithmen Problemstellungen \Omega untere Schranke asymptotische Laufzeit obere Schranke Form z Komplexitätsklasse Aufwandsmaß z B. quadratisch Notation Definitionen Landau-Symbole konstante Faktoren Konstanten großen Teilen verwendeten Maschinenmodell implementierten Algorithmen Qualität Compilers diversen Eigenschaften Hardware ausführenden Computer abhängig Aussagekraft Komplexität Algorithmus Bildung Komplexitätsklassen wesentliche Aufgabe Komplexitätstheorie sinnvolle Komplexitätsklassen vorliegenden Probleme Aussagen wechselseitigen Beziehungen Klassen Einflussgrößen Bildung Komplexitätsklassen Reihe Faktoren Einfluss Bildung Komplexitätsklassen wichtigsten folgenden liegende Berechnungsmodell Turingmaschine Registermaschine verwendete Berechnungsmodus deterministisch nichtdeterministisch probabilistisch betrachtete Berechnungsressource Zeit Platz Prozessoren angenommene Kostenmaß uniform logarithmisch eingesetzte Schrankenfunktion Anforderungen Schrankenfunktionen Angabe Definition Komplexitätsklassen Schrankenfunktionen DTIME Klasse Probleme deterministischen Turingmaschine Zeit Schrankenfunktion Schrankenfunktion komplexitätstheoretische Analysen Funktion folgenden Anforderungen f\colon \rightarrow Schrittzahl Speicher natürliche Zahlen monotones Wachstum Funktion Zeit Raum berechenbar Raum-/Zeitkonstruierbarkeit Funktion Anforderungen echte Komplexitätsfunktion Sinn Anforderungen Teil technischer Natur Schrankenfunktion konstruktive Art Beispiel Turingmaschine Beweise Zwecke gutartig Stelle Wahl Schrankenfunktion gewisse Vorsicht bestimmte algorithmische Techniken Praxis auftretenden Funktionen genannten Einschränkungen konstante Funktion Logarithmusfunktion Wurzelfunktion Polynome Exponentialfunktion Kombinationen Funktionen Übersicht wichtigsten Schrankenfunktionen üblichen Sprechweise Angabe üblich O-Notation wichtigsten Schrankenfunktionen konstant logarithmisch polylogarithmisch \log^k linear linearithmisch quadratisch Hierarchiesätze gebildeten Klassen zusätzlich bereitgestellte Ressourcen tatsächlich Probleme Beweise Hierarchiesätze Separationssätze Klassen jeweiligen Ressource Hierarchie Klassen echte Teilmengenbeziehung echten Teilmengenbeziehungen Aussagen groß Erhöhung Ressource größere Zahl Problemen besonderem Interesse Ressourcen Zeit Raum induzierten Hierarchien Zeithierarchie Raumhierarchie Hierarchiesätze Fundament Separierung Komplexitätsklassen frühesten Ergebnisse Komplexitätstheorie Hierarchiesätze diversen Voraussetzungen Voraussetzungen genannten Anforderungen echte Komplexitätsfunktionen Einhaltung Anforderungen tatsächlich gesamte Klassenhierarchie zusammen.Derartige Probleme Bereich probabilistischen Komplexitätsklassen praktisch verwendbare probabilistische Algorithmen erforderlich Fehlerwahrscheinlichkeit Komplexitätsklassen aufzählbar Separationsverfahren Voraussetzung Ergebnis Polynomzeitalgorithmen plötzlich Linearzeitalgorithmen Beispiel sensibel Geflecht Voraussetzungen abgeleiteten Sätzen Zeithierarchiesatz Zeithierarchiesatz \sdot Probleme asymptotischer Zeitbedarf deterministischen Turingmaschine Klasse \sdot ähnliche Beziehung nichtdeterministische Turingmaschinen Raumhierarchiesatz Raumhierarchiesatz \sdot Aussage analog Zeithierarchiesatz Vergleich Zeit geringere Steigerung Raumes Faktor Vergleich größere Klasse intuitiven Erwartung Raum Wiederverwendbarkeit alte Zwischenergebnisse gutmütiger Hierarchiesätze Hierarchiesätze gleichen Berechnungsmodus einzelne Ressource Beispiel Ressource Zeit deterministischen Maschinenmodell Aussage Zeitklassen verhalten Verhältnis deterministische nichtdeterministische Klassen derartige Zusammenhänge Abschnitten Beziehungen Zeitklassen Beziehungen deterministischen nichtdeterministischen Klassen Wichtige Zeitklassen DTIME Allgemeine Schreibweise deterministische Zeitklassen Deterministisch Polynomialzeit entscheidbare Sprachen EXPTIME Deterministisch Exponentialzeit entscheidbare Sprachen NTIME Allgemeine Schreibweise nichtdeterministische Zeitklassen NP Nichtdeterministisch Polynomialzeit entscheidbare Sprachen NEXPTIME Nichtdeterministisch Exponentialzeit entscheidbare Sprachen NC Parallel polylogarithmischer Zeit berechenbare Funktionen Wichtige Raumklassen DSPACE Allgemeine Schreibweise deterministische Raumklassen L Deterministisch logarithmisch beschränktem Raum entscheidbare Sprachen PSPACE Deterministisch polynomial beschränktem Raum entscheidbare Sprachen NSPACE Allgemeine Schreibweise nichtdeterministische Raumklassen Nichtdeterministisch logarithmisch beschränktem Raum entscheidbare Sprachen Kontextsensitive Sprachen nichtdeterministisch linear beschränktem Raum entscheidbaren Sprachen Liste Komplexitätsklassen Komplementbildungen Komplexitätsklasse K Komplementklasse CoK Komplementklasse Komplemente Elemente ursprünglichen Klasse K Menge Sprachen K Potenzmenge Komplementklasse CoK L L K entsprechenden Entscheidungsprobleme CoK Probleme Instanzen Antwort gegensätzlich Problem K. Gegensatz Komplement Klasse K Sprachen/Probleme gegebenen Grundmenge K Probleme Regel schwerer K. Komplementklasse CoK K Regel nichtleeren Durchschnitt deterministische Maschinen Regel CoK Übergangsfunktion Übergänge akzeptierenden Zuständen Übergänge verwerfenden Zuständen umgekehrt andere Berechnungsmodi Akzeptanz unbekannt NP CoP wahr liegende Modell deterministisch akzeptierenden ablehnenden Zustände Berechnungen einfach vorherigen Absatz P Durchschnitt NP CoNP Durchschnitt P bekannt P-NP-Problem Bedeutung wichtigsten ungelösten Probleme Komplexitätstheorie P-NP-Problem Klasse P Klasse NP Frage zentrale Forschungsmotivation Komplexitätstheorie Vielzahl komplexitätstheoretischen Ergebnisse Lösung Problems näher Klasse P Praktisch lösbare Probleme Tragweite P-NP-Problems Erfahrung Probleme Klasse P Regel praktisch lösbar Algorithmen Lösungen Probleme effizient vertretbarem zeitlichem Aufwand zeitliche Aufwand Problemlösung Probleme Klasse P maximal polynomial Regel Algorithmen Zeitfunktionen Polynome niedrigen Grades gewählte Maschinenmodell Zeitklasse deterministisch realisierbar Probleme Klasse P praktisch lösbaren Problemen Instanzen erheblicher Größe Klasse NP Effizient verifizierbare Probleme Algorithmen Lösung Probleme NP nichtdeterministischen Maschinenmodell Maschinen unbeschränkte Parallelisierbarkeit verzweigenden Berechnungspfade technisch Algorithmen Lösung Probleme NP polynomialer Zeit Basis physikalisch realisierbaren Maschinenmodells Alternativ Definition Nichtdeterminismus Klasse NP Verifikation Problemen Verifikationsalgorithmus eigentlichen Eingabe zusätzlich Zeugen Zertifikat Ja-Instanz Verifikationsalgorithmus möglichen Zeugen positiven Antwort Instanz Verifikationsalgorithmus Zeugen positiven Antwort Problem Verifikationsalgorithmus Zeugen polynomieller Länge polynomieller Zeit Problem Klasse NP Beispiel effizient verifizierbares Problem Erfüllbarkeitsproblem SAT boolesche Formel Belegung Variablen sodass Formel wahr möglicher Verifikationsalgorithmus Zeugen Vektor Variablenbelegung gegebene Variablenbelegung leicht effizienten Algorithmus Formel Belegung Problem Klasse NP Belegung Aufgabe Verifikationsalgorithmus nichtdeterministische Turingmaschine Problem NP möglichen Lösungen Rechenweg entsprechend Pfade anschließend Lösungen deterministisch weitere Verzweigung Probleme NP große Instanzen praktisch unlösbar NP-vollständigen Probleme Klasse Probleme Bereichen Informatik Probleme NP schwer NP Klasse P Fall NP Würde P-NP-Problem Sinne NP NP-vollständige Probleme Algorithmen polynomiellem Zeitaufwand umgekehrt Definition NP-Vollständigkeit Algorithmen beliebige Probleme NP polynomieller Zeit vollständige Probleme polynomialen Lösbarkeit einzigen NP-vollständigen Problems Probleme Klasse NP polynomieller Zeit lösbar Problemlösekraft gesamten Informatik Folge große Fortschritte Hardware-Entwicklung bestimmte Anwendungsfälle Lösung P-NP-Problems Sinne NP unerwünscht asymmetrische Verschlüsselungsverfahren erheblich Sicherheit Polynomialzeit Fall P NP Würde P-NP-Problem Sinne NP klar weitere Bemühungen polynomielle Lösungen NP-vollständige Probleme sinnlos leicht hohen Bedeutung Probleme NP Bemühungen effiziente Lösung unmöglich Zeitpunkt private öffentliche Forschungsenergie Theoremen P NP Beweis Gleichheit effektive Forschungsarbeit Auswegen Approximationen Heuristiken Problemeinschränkungen Praxis Konsequenzen Komplexitätstheorie wichtigsten Forschungszielen Komplexitätstheorie Abgrenzung praktisch Machbaren Betätigungsfeldes Informatik vorherigen Abschnitte Wichtigkeit Grenzziehung Zuge Versuche P-NP-Problem Komplexitätstheorie zahlreiche Ergebnisse Tage Analysemethoden Zug Zug Ergebnisse Entwurf Analyse praktisch wichtiger Algorithmen unmittelbar Praktische Informatik Jahren andauernden Bemühungen P-NP-Problem praktischen Informatiker großes Maß Sicherheit isolierte Bemühungen effizienten Lösung Problemen NP sinnlos praktische Informatik Lösung Probleme NP Näherungslösungen Abwandlung ursprünglichen Probleme Problemkomplexität Optimierungs-Algorithmen enorm optimale Lösung optimalen Lösung zufrieden Komplexitätstheorie Vorgehensweise theoretische Rückendeckung Sprachen Komplexitätsklassen folgende Inklusionsdiagramm groben Überblick Zusammenhänge Klassen Berechenbarkeitstheorie Chomsky- Hierarchie bedeutendsten Komplexitätsklassen 400px|zentriert|Inklusionsdiagramm Geschichte Komplexitätstheorie vorhergehenden Abschnitten zahlreiche Grundbegriffe wichtige Ergebnisse Komplexitätstheorie folgenden Abschnitten geschichtlicher zeitliche Abfolge Ergebnisse Grundlagen eigentlichen Beginn explizit Komplexität Algorithmen bezogenen Forschung zahlreiche Grundlagen wichtigste Konstruktion Turingmaschine Alan Turing Jahr spätere Algorithmen-Analysen ausgesprochen flexibles Modell erste informelle komplexitätstheoretische Untersuchungen Ergebnisse John Myhill Raymond Smullyan Hisao Yamada speziellen zeitbeschränkten Problemklassen Arbeiten Ansatz allgemeinen Theorie Beginn komplexitätstheoretischen Forschung ersten großen Schritt Richtung Theorie Juris Hartmanis Richard E. Stearns erschienenen Arbeit quantitative Definition Platzkomplexität Ressourcen wichtigsten Turingmaschine Grundlage robuste Entscheidung komplexitätstheoretischen Feldern Bestand erste Hierarchiesätze folgenden Jahren Reihe fundamentaler Ergebnisse Manuel Blum Speedup- Theorem Union-Theorem Edward M. McCreight Albert R. Meyer Allan Borodin Gap-Theorem Ergebnisse grundlegend Komplexitätstheorie Abtasten neuen Forschungsgebietes spektakuläre Ergebnisse Theoreme T. überraschende Aussagen Annahmen echten Komplexitätsfunktionen Zeit ersten Jahre komplexitätstheoretischer Forschung Formulierung Klasse P Klasse praktisch lösbaren Probleme Alan Cobham Polynomialzeit robust Wahl Maschinenmodells erweiterten Turing These mathematische Funktionen Polynomialzeit berechenbar Erforschung Klasse NP Klasse NP Jack Edmonds informelle Definition Tatsache zahlreiche wichtige Probleme NP Klasse attraktives Forschungsfeld Begriff Reduzierbarkeit basierende NP-Vollständigkeit Satz Cook prägnanten Ausdruck Erfüllbarkeitsproblem SAT vollständig schwerstes Problem NP ursprüngliche Arbeit Stephen Cook Tautologien aussagenlogische Formeln Belegung Begriff Erfüllbarkeit Ergebnisse Tautologien relativ einfach Erfüllbarkeit Stephen Cook Teil Übertragung Richard Karp Technik Reduktion Völlig unabhängig Arbeiten Leonid Levin damaligen Sowjetunion Theorie NP-Vollständigkeit Westen lange Zeit unbeachtet Michael R. Garey David S. Johnson Buch NP-vollständige Probleme Computers Buch künftige Forscher wichtigen Referenz Randomisierte Komplexitätsklassen Andrew Yao Konzept Falltürfunktionen spezielle Art Einwegfunktionen one grundlegende Wichtigkeit Kryptographie Schwierigkeit Code Worst-Case- Betrachtungsweise Komplexitätsklassen NP Algorithmen Probleme signifikanten Anteil Fälle effizient Modell probabilistischen Turingmaschine Einführung randomisierter Komplexitätsklassen PP ZPP RP BPP John T. Gill Übersicht wesentlichen Grundsteine Geschichte Komplexitätstheorie anderen Forschungsgebieten neueren Ergebnisse spezielle Teilbereiche Komplexitätsklassen Quanteninformationstheorie Quantencomputer Literatur Ding-Zhu Du Ker-I Ko John Wiley Sons New York Steve Homer 14. November PDF Michael R. Garey David S. Johnson Computers NP-completeness Freeman New York Juris Hartmanis Richard E. Stearns Vol S PDF Jan van Leeuwen Hrsg Handbook Computer Science The Press/Elsevier Amsterdam Christos Papadimitriou Computational Complexity Addison-Wesley Reading/Mass Rüdiger Reischuk Komplexitätstheorie Band Grundlagen Maschinenmodelle Platzkomplexität Nichtdeterminismus Auflage Teubner Stuttgart/Leipzig Michael Sipser Auflage Thomson Boston International Edition Ingo Wegener Komplexitätstheorie Grenzen Effizienz Algorithmen Auflage Springer Berlin Weblinks Zoo Verzeichnis wichtigsten Komplexitätsklassen Fußnoten